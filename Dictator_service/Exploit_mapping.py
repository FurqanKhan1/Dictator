"""
@Author		:Furqan Khan
@Email		:furqankhan08@gmail.com
@Date 		:1/2/2017

Objective :
The purpose of this file /module /Class is to read from exploits table present in the database by invoking appropriate exploits table model class and once it rreads the details it will generate the final report which contains mapped exploits with cve's or OSVDB id's.

Basically this module is used for on the fly nessus/qualys report to cve mapping.
A user can invoke this code by passing the nessus or qualys file (one of two at one time) and user may choose final format of report.This module will invoke the nessus or qualys parser depending upon the input tyoe and will then get parsed data from nessus/qualys parser and finally would traverse through thae data and would map cve to exploits and produce final report.
"""
import Qualys_parser
import Nessus_parser
import itertools
import uuid
import Report_Generator
import Report_printer
import os
import json
import zipfile

class Exploit_mapping:
	"""
	Objective :
	This is the Exploit_mapping class and has responsibility of mapping cve's and osvdb's present in nessus /
	qualys report to their appropriate metasplout and exploit db or extarnal url based exploits.
	"""

	def __init__(self,Nessus_report=None,Qualys_report=None):
		"""
		Objective :
		This is the constructor of the class and it initialises the various variables
		"""
	
		self.Nessus_report=None
		self.Qualys_report=None
		self.rp=Report_printer.Report_printer("parse_only")
		self.rg=Report_Generator.ReportGenerator()
		self.folder_dir=os.path.dirname(os.path.realpath(__file__))
		self.results_path=os.path.join(self.folder_dir,"Results_mapping")
		#print "\n\nResult path is : "+str(results_path) 
		self.folder_name=os.path.join(self.results_path,"Data_")
				
		if Nessus_report and Nessus_report !='':
			self.Nessus_report=Nessus_report
		if Qualys_report and Qualys_report !='':
			self.Qualys_report=Qualys_report




	def init_project_directory(self,project_id):
		"""
		Objective :
		This is the method which would actually go ahead and create a directory which would not be already
 		present and the final produced report will be present in this directory,which will be further zipped 
		and shared with user
		"""
	
		print "Initialising parent directory "
		try:
			if not os.path.exists(self.folder_name+str(project_id)):
				#print "Making directory !! folder name is"+str(self.folder_name)
				#self.print_Log("Making project directory !")
				os.mkdir(self.folder_name+str(project_id))
				s_path=os.path.join(self.results_path,'bk')
				#d_path=os.path.join(self.results_path,'bk')	
				
				os.system("cp -r "+s_path+ " "+ self.folder_name+str(project_id)+"/")

				#print "hhh"
			self.data_path=self.folder_name+str(project_id)
			return 1;
		except Exception ,ee:
			#self.print_Error("Error while creating directory !!"+str(ee))
			print "EX "+str(ee)
			return -1

	def generate_report(self,format_):
		"""
		Objective :
		This is the method which would actually go ahead and read the persed data from qualys /nessus parser.
		Depending upon the format of the report chosen by the user the ,it would invoke the report printer
 		module and would print the report in a zipped folder.Finally the path at which the zipped folder
 		lies is returned.
		"""

		try:
			report_content=None
			ret_resp={}
			if self.Nessus_report !=None and self.Qualys_report==None:
				nessus=Nessus_parser.Nessus_Parser()				
				nessus_results=None		#	('m.nessus','0','',"return"))	
				nessus_results=nessus.parse(self.Nessus_report,0,'',"return")
				if(nessus_results):
					if nessus_results["status"]=="success":
						report_content=nessus_results["value"]

			elif self.Qualys_report !=None and self.Nessus_report==None :
				qualys=Qualys_parser.QualysParser()
				qualys_results=None
				qualys_results=qualys.parse(self.Qualys_report,0,"return")
				#print "Wolla the q results are \n\n "+str(qualys_results)
				if qualys_results:
					if qualys_results["status"]=="success":
						report_content=qualys_results["value"]
			else:
				ret_resp["status"]="empty"
				ret_resp["value"]="The module works with either 1 of qualys or nessus report at 1 time "
				return ret_resp
				
				
			if report_content:
				rep_id=uuid.uuid1()
				self.data_path=self.folder_name+str(rep_id)
				print "format is :"+str(format_)
				if format_=="html":
					val=self.rp.generate_html(report_content,rep_id)
					print val
					if val and val["status"]=="success":
						ret_resp["status"]="success"
						ret_resp["value"]=val["value"]
					else:
						print "Val is nothing -->"+str(val)
						return val
					
				elif format_=="xml":
					val=self.rp.generate_xml(report_content,rep_id)
					print val
					if val and val["status"]=="success":
						ret_resp["status"]="success"
						ret_resp["value"]=val["value"]
				
					else:
						print "Val is nothing -->"+str(val)
						return val
					
				elif format_ =="csv":
					print "in csv 1"
					val=self.rp.generate_csv(report_content,rep_id)
					print val
					if val and val["status"]=="success":
						ret_resp["status"]="success"
						ret_resp["value"]=val["value"]
					else:
						print "Val is nothing -->"+str(val)
						return val
					
				elif format_=="json":
					stat=self.init_project_directory(rep_id)
					if stat==-1:
						#ret_resp={}
						ret_resp["status"]="failure"	
						ret_resp["value"]="Some error occured while initializing project directory"
						return ret_resp
			
			
					self.data_path=self.folder_name+str(rep_id)
					report_file=str(rep_id)+"__report.json"
					report_file_path = os.path.join(self.data_path, report_file)
					
					with open(report_file_path,"w") as f:
						try:
							json.dump(report_content,f,sort_keys=True,indent=4)
						except Exception ,eee:
							print "Exception while dumping :"+str(eee)

					zip_folder_name="Data_json_"+str(rep_id)+".zip"
					zip_folder_creation_path=os.path.join(self.results_path,zip_folder_name)
					zip_folder_path=self.data_path #file to be zipped
					zipf=zipfile.ZipFile(zip_folder_creation_path,'w',zipfile.ZIP_DEFLATED)
					self.rp.zipdir(zip_folder_path,zipf,report_file,"json")
					zipf.close()
					ret_resp={}
					ret_resp["status"]="success"
					ret_resp["value"]=zip_folder_creation_path
					print ret_resp
					return ret_resp

					#ret_resp["status"]="success"
					#ret_resp["value"]=self._Get_Download_link(rep_id)
				else:
					ret_resp["status"]="failure"
					ret_resp["value"]="Only json,xml,html and csv file formats are supported"
					
				return ret_resp


			else:
				ret_resp["status"]="empty"
				ret_resp["value"]="The parsing module did no return any result "
				return ret_resp
					
		except Exception,ee:
			print "Exception caught :"+str(ee)
			ret_resp["status"]="failure"
			ret_resp["value"]=str(ee)
			return ret_resp
					

	def _Get_Download_link(self,report_id):
		print "Download complete ... for report id :"+str(report_id)
		return "Download complete ... for report id :"+str(report_id)
	
#obj=Exploit_mapping('','metasploit.xml')
#obj=Exploit_mapping('m.nessus','')
#obj.generate_report('json')
#obj.generate_report('xml')

#print str(obj.parse('m.nessus','0','',"return"))









