"""
@Author		:Furqan Khan
@Email		:furqankhan08@gmail.com
@Date 		:1/2/2017

Objective :
The purpose of this file /module /Class is to call the backend database table IPexploits and pass the exploit details to it.It will save update ,delete and reterive details from IPexploits table and thus acts like a model class for the database table IPexploits
"""
import MySQLdb
import Auto_logger
import threading
import time
import ast
import json
import datetime
from ansi2html import Ansi2HTMLConverter
from ansi2html_ import ansi2html
import os 

class IPexploits:
	"""
		Objective :
		The purpose of this class is to pass the details to the backend IPexploits table .
		It acts like a model class which just communicates with the database layer
	"""
	def __init__(self,Pid=None,Host=None,Port=None,Service=None,Project_status=None,Exploits=None,service_status=None,Command_id=None):
		"""This is the init /Constructor of the given class"""		
		self.id=None
		self.Pid=Pid
		self.Host=Host
		self.Port=Port
		self.Service=Service
		self.Project_status=Project_status
		self.Exploits=Exploits
		self.Command_id=None
		self.service_status=service_status
		self.con=None
		self.cursor=None
		self.logger=None
		self.project_id="Default"
		self.lock = threading.Lock()
		self.Auto_logger=Auto_logger.Logger()
		self.method_id="INIT"
		self.All_exploits=[]
		self.conv = Ansi2HTMLConverter()
		self.data_path=""
		


	def init_connection(self):
		"""
			Objective :
			This method would initialise the database connection
		"""
		try:
			self.method_id="Init_connection()"
			self.folder_dir=os.path.dirname(os.path.realpath(__file__))
			user=''
			password=''
			try:
				db_file=os.path.join(self.folder_dir,"db_file.txt")
				with open(db_file ,"r+") as db:	
					user_pass=db.read()
					user_pass=user_pass.replace("\n","").replace("\r\n","").replace("\r","")
					user_pass=user_pass.split(":")
					user=user_pass[0]
					password=user_pass[1]
					
			except Exception ,eex:
				print "EXception ! " +str(eex)
				
			self.con=MySQLdb.connect("localhost",user,password,"nmapscan")
			self.cursor = self.con.cursor()
		except Exception,ee:
			self.print_Error("EXception in connection-->"+str(ee))

	def close_connection(self):
		"""
			Objective :
			This method would close the database connection
		"""
		try:
			self.method_id="Close_connection()"		
			if self.con.open:
				self.con.close()
		except Exception, ee:
			self.print_Error("EXception in connection-->"+str(ee))


	def getIpExploitPolling(self,project_id,read_status):
		"""
		Objective :
		The purpose of this method is to select the records from IPexploits table which have not been read
		and have the status marked as complete.Ideally its used with concurrent scans.The idea is to poll the
		records and update the ui every time a service scan finishes the vulnerability scanning.
		The record is updated only when the data is read at ui level thus makes a round trip
		"""
	
		try:
			#all_exploits=[]
			self.init_connection()
			self.method_id="GetIPExploitPolling()"
			self.print_Log("Starting method --> "+self.method_id)
			id_=int(project_id)
			ret_resp={}
			if 1:
				self.cursor.execute("select count(*) from  IPexploits  where service_type = 'existing' and Pid = %s and read_init_status = %s" ,(id_,read_status))#launchConfiguration
				counter=self.cursor.fetchone()
				print "value of counter is :"+str(counter)
				if (counter[0]  > 0):
					self.cursor.execute("select * from  IPexploits  where service_type = 'existing' and Pid = %s and read_init_status = %s" ,(id_,read_status))
					all_exploits= self.cursor.fetchall()
					ret_resp["status"]="success"
					ret_resp["value"]=all_exploits
				else:
					ret_resp["status"]="empty"
					ret_resp["value"]="0"
				self.close_connection()
			return ret_resp

		except Exception ,ee:
			print str(ee)
			self.print_Error("Exception ipExploitPolling  -->"+str(ee))
			ret_resp["status"]="failure"
			ret_resp["value"]=str(ee)
			self.close_connection()
			return ret_resp

	def getIpExploitPollingResult(self,project_id,read_status):

		"""
		Objective :
		The purpose of this method is to poll the exploits table if scan is running in sequential mode
		and the moment scan is over it would return all the results obtained from vulneraibility scanning 			"""

		try:
			#all_exploits=[]
			self.init_connection()
			self.method_id="GetIPExploitPolling()"
			self.print_Log("Starting method --> "+self.method_id)
			id_=int(project_id)
			ret_resp={}
			if 1:
				self.cursor.execute("select count(*) from  IPexploits  where (project_status='complete' and Pid =%s and read_final_status = %s) or (test_case_executed='true' and Pid =%s)" ,(id_,read_status,id_))#launchConfiguration
				counter=self.cursor.fetchone()
				print "value of counter is :"+str(counter)
				if (counter[0]  > 0):
					self.cursor.execute("select * from  IPexploits  where (project_status='complete' and Pid= %s and read_final_status = %s) or (test_case_executed='true' and Pid =%s)",(id_,read_status,id_))
					all_exploits= self.cursor.fetchall()
					ret_resp["status"]="success"
					ret_resp["value"]=all_exploits
				else:
					ret_resp["status"]="empty"
					ret_resp["value"]="0"
				self.close_connection()
			return ret_resp

		except Exception ,ee:
			print str(ee)
			self.print_Error("Exception ipExploitPollingResult  -->"+str(ee))
			ret_resp["status"]="failure"
			ret_resp["value"]=str(ee)
			self.close_connection()
			return ret_resp

	def getIpExploit(self,project_id,record_list=[]):
		"""
		Objective :
		The purpose of this method is to reterive the vul scan details for current project and 
		the record id's passed in the record_list [] list.
	
 		"""

		try:
			#all_exploits=[]
			print "Record list is :"+str(record_list)
			#self.init_connection()
			format_strings=','.join(['%s'] * len(record_list)) #will convert to val like %s,%s,%s,%s ..
			self.init_connection()
			sql_query="select * from  IPexploits  where service_type = 'existing' and id in (%s) and Pid = %%s" % format_strings 
			print "SQL QUERY IS :" +str(sql_query)
			args=record_list +[int(project_id)]
			self.cursor.execute(sql_query,args)
			all_exploits= self.cursor.fetchall()
			print "Record list is :-->"+str(record_list)
			print "Obtained records from db are :\n\n\n"+str(all_exploits)+"\n\n\n\n"
			self.close_connection()
			print "success"
			return all_exploits

		except Exception ,ee:
			self.print_Error("EXception ipExploit -->"+str(ee))
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()
			return -1


	def getIpExploits(self,project_id,top_records=None,resume=False):
		"""
		Objective :
		The purpose of this method is to reterive all the vul scan details for current project 
	
 		"""

		try:
			
			#all_exploits=[]
			self.init_connection()
			self.method_id="GetIPExploits()"
			self.print_Log("Starting method --> "+self.method_id)
			id_=int(project_id)
			if top_records ==None:
				if resume==False:
					self.cursor.execute("select * from  IPexploits  where Pid=%s and service_type = 'existing'",(id_,))#launchConfiguration
				else: #resume
					self.cursor.execute("select * from  IPexploits  where Pid=%s and project_status <> 'complete' and service_type = 'existing'",(id_,))#
			else: #threading
				print "Obtained limit is :" +str(top_records)
				self.cursor.execute("select * from  IPexploits  where Pid=%s and service_type = 'existing' and project_status <> 'processing' and project_status <> 'complete' limit %s ",(id_,int(top_records)))#launchCo

			all_exploits= self.cursor.fetchall()
			self.close_connection()
			print "success"
			return all_exploits

		except Exception ,ee:
			self.print_Error("EXception -->"+str(ee))
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()
			return -1

	
	def getStatus(self,project_id):
		"""
		Objective :
		The purpose of this method is to reterive the project_status with respect to vul_scanning
		and current project id and tells weather the project is paused or not
 		"""

		try:
			self.init_connection()
			self.cursor.execute("select project_status_exploits from project where  id=%s",(int(project_id),))
			status=self.cursor.fetchone()
			if status :
				if(str(status[0])=='paused'):
					self.close_connection()
					return 1;
				else:
					self.close_connection()
					return 0;
			else :
				self.close_connection()
				return 0;

		except Exception, ee:
			self.print_Error("Exception get status "+str(e))
			self.close_connection()
			return 0


	def return_service(self,pid,rec_id):
		"""
		Objective :
		The purpose of this method is to reterive the services detected for current project_id
	
 		"""
		try:
			ret_val={}
			self.init_connection()
			self.cursor.execute("select service from IPexploits where Pid= %s and id=%s",(int(pid),int(rec_id)))
			status=self.cursor.fetchone()
			if status :
				ret_val["status"]="success"
				ret_val["value"]=status[0]
				#return status[0]
			else :
				ret_val["status"]="failure"
				ret_val["value"]="0"
			self.close_connection()
			return ret_val

		except Exception ,ee:
			self.close_connection()
			ret_val["status"]="failure"
			ret_val["value"]=str(ee)
			return ret_val

	
	def checkPollingStatus(self,max_val,project_id):
		
		self.method_id="checkPollingStatus()"
		self.print_Log("Started")

		all_status=[]
		ret_val={}
		try :
			if(project_id):
				self.init_connection()
				self.cursor.execute("select count(id) from IPexploits where Pid=%s and((project_status='processing' and service_type='existing'))",(int(project_id),))
				status=self.cursor.fetchone()
				if(1):
					if int(status[0]) < max_val: #could be 0 could be <10
						self.cursor.execute("select count(id) from IPexploits where Pid=%s and((project_status='init' and service_type='existing') or (project_status='update' and service_type='existing'))",(int(project_id),))
						stat=self.cursor.fetchone()
						if int(stat[0])==0:
							if int(status[0])==0:
								ret_val["status"]="complete"
							else:
								ret_val["status"]="pass"
							ret_val["value"]=0
						else:
							ret_val["status"]="pull"
							pull_val=max_val - int(status[0])
							ret_val["value"]=pull_val
					elif int(status[0])==max_val:
							ret_val["status"]="pass"
							ret_val["value"]=0
					else:
						print "Not possibe some error !! " +str(int(status[0]))
						ret_val["status"]="error"
						ret_val["value"]="The value of processing cant be greater than max permitted"
					
				self.close_connection()				
				self.print_Log("Ended")
				return ret_val
			else:
				ret_val["status"]="error"
				ret_val["value"]="Project id not supplied !!"
				return ret_val
		
		except Exception ,ee:
			print "Exception 167" +str(ee) 
			self.print_Error("Exception checkPOllingStatus" +str(ee) )
			self.close_connection()
			ret_val["status"]="error"
			ret_val["value"]=str(ee)
			return ret_val

	def checkStatus(self,project_id):
		#print "Checking processing status !!! !!!!! for project "+str(project_id)
		"""
		Objective :
		The purpose of this method is to reterive the project_status with respect to vul_scanning
		and current project id.It tells weather the there is any record with status as init,incomplete or
		processing.It aids in vul scanning with threading switch where before terminating the polling
		service it is essential to check if the project status is complete or not.
	
 		"""
		self.method_id="CheckStatus()"
		self.print_Log("Started")
		all_status=[]
		try :
			if(project_id):
				self.init_connection()
				self.cursor.execute("select count(id) from IPexploits where Pid=%s and((project_status='processing' and service_type='existing') or (project_status='init' and service_type='existing') or (project_status='update' and service_type='existing'))",(int(project_id),))
				status=self.cursor.fetchone()
				if(int(status[0])):
					
					all_status.append(1)
					
				else:
					#conn.close()
					all_status.append(0)
					#return 0;
				self.close_connection()
				all_status.append(self.getStatus(project_id))
				
				self.print_Log("Ended")
				return all_status
		
		except Exception ,ee:
			print "Exception 16 " +str(ee) 
			self.print_Error("Exception checkStatus" +str(ee) )
			self.close_connection()


	def UpdateStatus(self,status,ipx,portx,project_id,record_id,update_all=False):
		"""
		Objective :
		The purpose of this method is to update the project_status with respect to vul_scanning
		and current project id.It updates the project_status to complete and read_status=false for mode
		of type concurrent and current record_id and if update_all flag is set then it updates project
 		status =complete for all the records.
	
 		"""
		try:
			self.init_connection()
			if update_all==False:
				self.cursor.execute("UPDATE IPexploits SET project_status = %s ,read_final_status='false'  WHERE Host=%s AND Port=%s AND Pid=%s and id=%s",(status,ipx,portx,int(project_id),int(record_id))) 
			else:
				self.cursor.execute("UPDATE IPexploits SET project_status = %s ,read_final_status='false'  WHERE Pid=%s and project_status='processing'",(status,int(project_id))) 			
			self.con.commit()	
			self.close_connection()	
		except Exception ,ee:
			self.print_Log("Inside exception update status "+str(ee))
			self.con.rollback()
			self.close_connection()

	
	def TestCaseStatus(self,status,ipx,portx,project_id,record_id,update_all=False):
		"""
		Objective :
		The purpose of this method is to update the project_status with respect to vul_scanning
		and current project id.It updates the project_status to complete and read_status=false for mode
		of type concurrent and current record_id and if update_all flag is set then it updates project
 		status =complete for all the records.
	
 		"""
		try:
			self.init_connection()
			if 1:#update_all==False:
				self.cursor.execute("UPDATE IPexploits SET test_case_executed = %s WHERE Host=%s AND Port=%s AND Pid=%s and id=%s",(status,ipx,portx,int(project_id),int(record_id))) 
			self.con.commit()	
			self.close_connection()	
		except Exception ,ee:
			self.print_Log("Inside exception--- update status "+str(ee))
			self.con.rollback()
			self.close_connection()

	def UpdateProjectStatus(self,status,project_id,concurrent=False):
		"""
		Objective :
		The purpose of this method is to update the project_exploits_status =complete in projects table 
		when all the commands for vul scanning would be executed
 		"""
		try:
			self.init_connection()
			if concurrent==False:
				self.cursor.execute("UPDATE project SET project_status_exploits =%s where  id=%s",(status,int(project_id))) 
				self.con.commit()
			else:
				self.cursor.execute("select project_status from project where id=%s",(int(project_id),))
				status=self.cursor.fetchone()
				if status[0]=='complete':
					self.cursor.execute("select ((select count(id) from IPexploits where Pid=%s)-(select count(id) from IPexploits where (project_status='complete' or project_status='error-complete') and Pid=%s)) as result",(int(project_id),int(project_id)));
					res=self.cursor.fetchone()
					if (int(res[0]) ==0):
						self.cursor.execute("UPDATE project SET project_status_exploits =%s where  id=%s",(status,int(project_id)))
						
						self.con.commit()
						self.close_connection()
						self.generate_report(project_id)
			self.close_connection()
					
				
					
			
		except Exception ,ee:
			self.print_Log("Inside exception update project status "+str(ee))
			self.con.rollback()
			self.close_connection()

	def Update_Reconfig(self,id_,pid,host,port,service,service_type,exploit_template,service_only=False):
		"""
		Objective :
		The purpose of this method is to update and reconfigure the records which the user wants to update.
 		"""
		try:
			self.method_id="Reconfigure-Update"
			print "Here"
			if self.logger is not None:
				self.print_Log("Inside update-Reconfig")
			self.init_connection()#Pid,Host,Port,Service,Project_status,Exploits)
			print (id_,pid,host,port,service,service_type,str(exploit_template))
			#('2788', '185', '192.168.179.136', '1099', 'ftp', 'existing')
			if(service_only==False):
				print "11"
				self.cursor.execute("update IPexploits set Host=%s ,Port=%s ,Service =%s ,service_type=%s,Exploits=%s where Pid=%s and id=%s",(host,port,service,service_type,exploit_template,int(pid),int(id_)))
			elif(service_only==True):
				self.cursor.execute("update IPexploits set Service =%s ,service_type=%s,Exploits=%s where Pid=%s and id=%s",(service,service_type,exploit_template,int(pid),int(id_)))
			self.con.commit()
			self.close_connection()
			if self.logger is not None:
				self.print_Log("Finished update-Reconfig")
			

		except Exception ,ee:
			if self.logger is not None:
				self.print_Error("Exception reconfig !!! " +str(ee))
			self.con.rollback()
			self.close_connection()
			
		
	def generate_report_GUI(self,project_id):
		"""
		Objective :
		The purpose of this method is to reterive the details of commands executed ,services and the results
		for the current project id.This method aids in report generation by returning list of dictionaries 
		that contain mannual results for the current project id passed .
	
 		"""
		try:
			return_response={}
			return_data_list=[]
			self.init_connection()
			id_=int(project_id)
			self.cursor.execute("select distinct Host from IPexploits  where service_type='existing' and  Pid=%s",(id_,))#launchConfiguration
			all_hosts= self.cursor.fetchall()
			for hosts in all_hosts:
				return_data={}
				data_list=[]
				return_data["host"]=hosts[0]
				self.cursor.execute("select Id,Pid,Host,Port,Service,Exploits from IPexploits where Pid=%s and Host =%s and service_type='existing'",(id_,hosts[0]))
				report_data=self.cursor.fetchall()
				for record in report_data:
					report_content={}
					report_content["id"]=str(record[0])
					report_content["Pid"]=str(record[1])
					report_content["host"]=str(record[2])
					report_content["port"]=str(record[3])
					report_content["service"]=str(record[4])
					exploit_data={}
					exploit_data=record[5]
					if(isinstance(exploit_data,basestring)):
						#print "1"
						exploit_data=json.loads(exploit_data)
					report_content["exploits"]=exploit_data					
					data_list.append(report_content)

				return_data["value"]=data_list
				return_data_list.append(return_data)
			if (len(return_data_list)>0):
				return_response["status"]="success"
				return_response["value"]=return_data_list
			else:
				return_response["status"]="empty"
				return_response["value"]="0"

			self.close_connection()
			return return_response


					
					

					
			
					
			
		except Exception, ex:
			print "Exception caught while retuning_report"
			return_response["status"]="failure"
			return_response["value"]=str(ex)
			return_response["errors"]=str(ex)
			self.close_connection()
			return return_response

	def generate_report(self,project_id):
		"""
		Objective :
		The purpose of this method is to generate HTML report for Command line version of code,
		based on findings by parsing and traversing through
		the output produced by automating mannual vulnerability scanning.
	
 		"""
		try:
			print ("Started generate report")
			self.method_id="Generate report"
			#self.print_Log("Started --> generate report")
			
			self.init_connection()
			html=[]
			html.append("<div>")
			id_=int(project_id)
			self.cursor.execute("select distinct Service from IPexploits  where service_type='existing' and  Pid=%s",(id_,))#launchConfiguration
			all_services= self.cursor.fetchall()
			service_counter=0
			host_counter=0
			exploits_=0
			all_exploits=0
			print "Reached here"
			print "All service langth :"+str(len(all_services))
			all_service=1;
			for service in all_services:
				all_service=all_service +1
				#34495E  #2F4F4F
				html.append("<div  class=row style='border-style:solid;border-width:thin;border-color:#34495E;Background-color:#FFF'><div class=' col-sm-12 alert alert-info' style='background-color:#34495E;color:white'><h4><span class='glyphicon glyphicon-th-large'></span>&nbsp;Service : <a href=#  style='text-decoration:none;color:white'>"+service[0]+"</a></h4></div>")
				self.cursor.execute("select Id,Pid,Host,Port,Service,Exploits from IPexploits where Pid=%s and Service =%s and service_type='existing'",(id_,service[0]))
				report_data=self.cursor.fetchall()
				html.append("<div class=col-sm-12 id=service_"+str(service_counter)+ " style='display:block'>")
				service_counter=service_counter +1
				for record in report_data:
					html.append("<br><div><a href=#host_"+str(host_counter)+ " data-toggle=collapse><span class='glyphicon glyphicon-list'></span>&nbsp;&nbsp;"+str(record[2])+"</a><br></div><div class=collapse id=host_"+str(host_counter)+"><br><table class='table table-condensed' style='background-color:#34495E;color:white'><tr><td>Host</td><td>"+str(record[2])+"</td></tr><tr><td>PORT</td><td>"+str(record[3])+"</td><tr><td>Service</td><td>"+str(record[4])+"</td></tr></table>")
					html.append("<div class=exploit_header><a href=#exploits_"+str(exploits_)+" data-toggle=collapse><font color =red><span class='glyphicon glyphicon-list'></span>&nbsp;<b>Test Cases AND Commands</b> </font></a><br></div><div id=exploits_"+str(exploits_)+" 'style=display:none;' class=collapse><br><br><div class=exploits_result>")
					exploit_data={}
					exploit_data=record[5]
					if(isinstance(exploit_data,basestring)):
						#print "1"
						exploit_data=json.loads(exploit_data)
					#exploit_data=dict(exploit_data)
					#if(isinstance(exploit_data,dict)):
						# "22"
					#print "Exploit data --> "+str(exploit_data)
					host_counter=host_counter+1
					exploits_=exploits_+1
					
					if exploit_data:
						entries=exploit_data.get("Entries")
						if(entries):
							print "true--" #use this foll logic at fron end while rep generation
							for k,v in entries.iteritems():
								print "Generating"
								if(v):
									#print "REached here--------->" +str(v)
									#print "here------>"+str(k)
									command_id=str(k)
									html.append("<b> <font color=green><span class='glyphicon glyphicon-info-sign'></span>&nbsp;Command Id : "+str(command_id)+"</font></b><br><br>")
									#v[0] will hold includes/or not
									commands = v[1] if v[1] else "No commands "								
									result=v[2] if v[2] else "No Results "
									final_commands=[]
									#print commands
									#print "aaa"
									if(commands !="No commands"):
										#print isinstance(commands,list)
										cmd = ast.literal_eval(commands)
										if (isinstance(cmd,list)):
											#print "inside if "
											for c in cmd:
												print "Found-"
												final_commands.append(c)
												
										else:
											print "Found"
											final_commands.append(str(cmd))
									#print "here v !!"
									commands=''.join(final_commands)
									all_exploits=all_exploits+1
									
									print "About to append"
									html.append("<div style=background-color:black;color:white>Command :<br>"+str(commands).replace("<","&lt").replace(">","&gt").replace('\n','<br>').replace('\r','<br>').replace('\r\n','').replace('\r\r','<br>')+"</div><br>")
									html.append("<div style=background-color:black;color:white>Results : <br>"+str(result.replace("<","&lt").replace(">","&gt")).replace('\n','<br>').replace('\r','<br>').replace('\r\n','').replace('\r\r','<br>') +"</div><br>")
									print "Appended"
					html.append("</div></div></div><br>")
				html.append('</div></div>')
				html.append("<div class=row style='background-color:#f1f1f1'><div class='col-sm-12'><br></div></div>")#close service div
				#print "Reached here also !!-->"+str(all_service)
													
					#html.append("<div class=exploit_header>EXPLITS AND COMMANDS"
					
					
			#self.con.commit()
			html.append("</div>")
			self.close_connection()
			self.folder_name=os.path.join("Results","Data_")
			print "Connection_closed"
			#self.print_Log("Finished Generating report")
			#self.data_path=self.folder_name+str(project_id)
			report_file=str(project_id)+"_report.html"
			report_file_path = os.path.join(self.data_path, report_file)
			print "Report file path is : "+str(report_file_path)
			output = open(report_file_path,"wb") #create a html report file and open it
			
			bootstrap='''<head>
  			
  			<meta charset="utf-8">
  			<meta name="viewport" content="width=device-width, initial-scale=1">
			<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
  			<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
			<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  			<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
			<script src="bootstrap/js/jquery.js"></script>
			<script src="bootstrap/js/bootstrap.min.js"></script>
			<script type='text/javascript'>
			
$(document).ready(function(){ 
	//alert('hello world'); 
$('.collapse').on('shown.bs.collapse', function(){
//alert('bye');
$(this).parent().find(".glyphicon-plus").removeClass("glyphicon-plus").addClass("glyphicon-minus");
}).on('hidden.bs.collapse', function(){
$(this).parent().find(".glyphicon-minus").removeClass("glyphicon-minus").addClass("glyphicon-plus");
});	
});		</script>
			</head>'''
			nav_bar='''<nav class="navbar navbar-inverse navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span> 
      </button>
     <p><a class="navbar-brand glyphicon glyphicon-king" style='color:red;position:relative;left:20%'><font color=red>-DICTATOR</font></a></p>
    </div>
    <div class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav" style=position:relative;left:3%>
	
        <li class="active"><a href="#">Scan Report</a></li>

      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="#"><span class="glyphicon glyphicon-user"></span> Sign Up</a></li>
        <li><a href="#"><span class="glyphicon glyphicon-log-in"></span> Login</a></li>
      </ul>
    </div>
  </div>
</nav>'''#e7e7e7
			output.write("<html><title>Nmap Scanning Result</title>"+bootstrap+"<body><div class='container-fluid' style=background-color:#f1f1f1>"+nav_bar+"<br><br><br><div class=col-sm-2 ><div class=row><div class='col-sm-12'><div class='col-sm-12' style='background-color:#6B8E23;color:white;text-align: center;'><h5><span class='glyphicon glyphicon-record'></span>&nbsp;Scan Summery</h5></div><div style=border-style:solid;border-width:thin;background-color:white><br><medium><font color=black><b>&nbsp;<span class='glyphicon glyphicon-ok-sign' style=color:#6B8E23></span>&nbsp; Date :"+str(datetime.datetime.now())[0:16]+"<br> &nbsp;<span class='glyphicon glyphicon-ok-sign' style=color:#6B8E23></span>&nbsp; Services : "+str(service_counter)+"<br>&nbsp;<span class='glyphicon glyphicon-ok-sign' style=color:#6B8E23></span>&nbsp; Test Cases : "+str(all_exploits)+"<br></b></font></medium></div><br><div class='col-sm-12' style='background-color:#6B8E23;color:white;text-align: center;'><h5><span class='glyphicon glyphicon-record'></span>&nbsp;Disclaimer</h5></div><div style=border-style:solid;border-width:thin;background-color:white><br><br><small><font color=red><ul class=list-group><li class=list-group-item><span class='glyphicon glyphicon-info-sign'></span>&nbsp;The scan results are subjected to Nmap's accurecy of determining open ports and avalible services.</li><li class=list-group-item><span class='glyphicon glyphicon-info-sign'></span>&nbsp;Nmap works on convention over exploration.If a well known port say 1433 is open,nmap assumes sql-server to be running on it,evn if some other service would be running.</li><li class=list-group-item><span class='glyphicon glyphicon-info-sign'></span>&nbsp;It is adviced that if the produced exploit results are strange ,then one must manually check for the service running on the port</li></ul></font></small></div></div></div></div><div class=col-sm-10 style=background-color:white>")
			print "wrote little"
			
			result_test = self.conv.convert(str(''.join(html)))
			html_final=ansi2html(str(''.join(html)))
			#output.write(str(''.join(html)))
			output.write(html_final)
			#output.write(str(result_test))
			#output = ansi2html('\033[1;32Hello\033[m')
			output.write(str("</div></div>"))
			#'''for l in result: #Note  result is a list of array.Each element is an array and holds multiple comma seperated values
				#output.write("<P><h3 style=""color:green;""><b>Service Name:</b></h3><h4>" + l[0] + "</h4></p><br>")
				#output.write("<p><h3 style=""color:blue;""><b>IP Address For Scanning:</b></h3><h4>" + l[2] + ":"+ l[3] +"</h4></p><br>")
				#output.write("<p><h3 style=""color:green;""><b>Script Checking:</b></h3><h4>" + l[1] + "</h4></p><br><br>")
				#output.write("<p><h3 style=""color:red;""><b>Command:</b></h3><h4>"+ l[4] + "</h4></p><br>")
				#output.write("<pre>" + l[5] + "</pre>" + "")
				#output.write("<br> <br> ")'''
			output.close()	
			print "Report generated successfully"
			#return str(''.join(html))
			
		except Exception ,ee:
			print ("Error "+str(ee))
			#self.print_Error("Exception occured in Method --" +str(ee))	
			self.close_connection()
			#self.print_Log("Error Generating report")	
						
	
	def Update(self,project_id,current_record_id,command_id,commands,result,is_file=False):
		"""
		Objective :
		The purpose of this method is to update the json template  (exploits column ) of IPexploits
 		table with the results obtained when the external scripts are executed..
	
 		"""
		try:

			self.init_connection()
			
			#print "Inside Update method with command id --->"+str(command_id)
			self.print_Log("Command id is ->" +str(command_id))
			self.print_Log("commands are : "+str(commands))
			
			
			command_id='"'+command_id+'"'
			command="$.Entries."+command_id
         		my_var=command
			my_var="'"+my_var +"'"
			self.print_Log("My var : "+str(my_var))
			#time.sleep(2)
			self.print_Log("Result --> : "+str(result))
			#print "\n\n\n Sql result is :"+str(result)
			#print "\n Sql command ::"+str(commands)
			#print "\n\n"
			sql_update="UPDATE IPexploits SET Exploits= JSON_REPLACE(Exploits, "+my_var+", JSON_ARRAY(true,%s,%s)) where id=%s and Pid=%s"
			
			#time.sleep(2)
			#print "\n\nSql to be executed --> "+sql_update			
			#time.sleep(3)
			
			self.cursor.execute(sql_update,(str(commands),str(result),int(current_record_id),int(project_id)))
		
			
			self.con.commit();
			self.close_connection()
			self.print_Log("Finished!!!")
			return 1

		except Exception ,ee:
			self.print_Error("EXception @@ -->"+str(ee))
			#self.print_Error("EXception -->"+str(ee))
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()
			return 0
	

	def UpdatePollingStatus(self,project_id,record_list):
		"""
		Objective :
		The purpose of this method is to update the polling status .Remember earlier discussed
 		read_init_status.It sets the value to True
	
 		"""
		try:
			format_strings=','.join(['%s'] * len(record_list)) #will convert to val like %s,%s,%s,%s ..
			self.init_connection()
			# "Format string is :-->"+str(format_strings)
			#print "tuple is :"+str(tuple(record_list))
			sql_query="update IPexploits set read_init_status='true' where id in (%s) and Pid=%%s"% format_strings
			print "SQL QUERY IS :" +str(sql_query)
			args=record_list +[int(project_id)]
			self.cursor.execute(sql_query,args)
			self.con.commit();
			self.close_connection()
			self.print_Log("Finished!!!")
			return 1

		except Exception ,ee:
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()
			return 0
			# 0

	def UpdatePollingStatusExploit(self,project_id,record_list,all_=None,status=None):
		"""
		Objective :
		The purpose of this method is to update the polling status .Remember earlier discussed
 		read_final_status.It sets the value to True.It means that when ever a record is returned to
		consuming service it must call this method immidiately after the ui is updated indicating 
		that the record is read
	
 		"""
		try:
	
			 #will convert to val like %s,%s,%s,%s ..
			self.init_connection()
			if all_==None and status==None:
				format_strings=','.join(['%s'] * len(record_list))
				sql_query="update IPexploits set read_final_status='true',test_case_executed='false' where id in (%s) and Pid=%%s"% format_strings
				#print "SQL QUERY IS :" +str(sql_query)
				args=record_list +[int(project_id)]
				self.cursor.execute(sql_query,args)
			else:
				print "Reached here all status will be updated to false !!!"
				self.cursor.execute("update IPexploits set read_final_status=%s where Pid=%s",(status,int(project_id)))
			self.con.commit();
			self.close_connection()
			self.print_Log("Finished!!!")
			return 1

		except Exception ,ee:
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()
			return 0


	def UpdatePollingStatusinit(self,project_id,record_list,all_=None,status=None):
		"""
		Objective :
		The purpose of this method is to update the polling status .Remember earlier discussed
 		read_final_status.It sets the value to True.It means that when ever a record is returned to
		consuming service it must call this method immidiately after the ui is updated indicating 
		that the record is read
	
 		"""
		try:
	
			 #will convert to val like %s,%s,%s,%s ..
			self.init_connection()
			if all_==None and status==None:
				format_strings=','.join(['%s'] * len(record_list))
				sql_query="update IPexploits set read_init_status='true' where id in (%s) and Pid=%%s"% format_strings
				#print "SQL QUERY IS :" +str(sql_query)
				args=record_list +[int(project_id)]
				self.cursor.execute(sql_query,args)
			else:
				print "Reached here all status will be updated to false !!!"
				self.cursor.execute("update IPexploits set read_init_status=%s where Pid=%s and project_status='init'",(status,int(project_id)))
			self.con.commit();
			self.close_connection()
			self.print_Log("Finished!!!")
			return 1

		except Exception ,ee:
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()
			return 0
	
	def getUnknownServicesOnlyPolling(self,project_id,status):
		"""
		Objective :
		The purpose of this method is to reterive the services with status marked as unknown.Thus this
		method acts as a polling method when the mode will be concurrent and during discovery if at 
		anytime we discover any service of type unknown ,then return that service.
		It would help in reconfiguration of unknown type services.
 		"""
		try:
			self.init_connection()
			ret_val={}
			self.cursor.execute("select count(*) from IPexploits where Pid=%s and (service_type='unknown' or service_type ='echo' or service_type='new') and read_init_status =%s",(int(project_id),status))
			counter=self.cursor.fetchone()
			if (counter[0] > 0):
				self.cursor.execute("select * from IPexploits where Pid=%s and (service_type='unknown' or service_type ='echo' or service_type='new' and read_init_status =%s)",(int(project_id),status))
				rows=self.cursor.fetchall()
				ret_val["status"]="success"
				ret_val["value"]=rows
			
			else:
				ret_val["status"]="empty"
				ret_val["value"]="0"
				
			self.close_connection()	
			return ret_val
		except Exception ,ee:
			self.close_connection()
			ret_val["status"]="failure"
			ret_val["value"]=str(ee)
			return ret_val


	def getUnknownServices(self,project_id):
		"""
		Objective :
		The purpose of this method is to reterive the services with status marked as unknown or echo or
		existing or new.This is not the polling method
 		"""
		
		try:
			self.init_connection()
			self.method_id="getUnknownServices"
			self.print_Log("Started getUNknown Services()")
			self.cursor.execute("select * from IPexploits where Pid=%s and (service_type='unknown' or service_type ='echo' or service_type='new' or service_type='existing')",(int(project_id),))
			rows=self.cursor.fetchall()
			self.close_connection()
			return rows
		except Exception ,ee:
			self.print_Error("Exception in GetUnknown Services"+str(ee))
			self.close_connection()

	def getUnknownServicesOnly(self,project_id,concurrent=False,record_list=[]):
		"""
		Objective :
		The purpose of this method is to reterive the services with status marked as unknown or echo or
		existing or new for gui mode and only for the records in the record_list[]
 		"""

		try:
			
			self.init_connection()
			self.method_id="getUnknownServices ONly"
			self.print_Log("Started getUNknownOnly Services()")
			if concurrent==False:
				self.cursor.execute("select * from IPexploits where Pid=%s and (service_type='unknown' or service_type ='echo' or service_type='new')",(int(project_id),))
				rows=self.cursor.fetchall()
			else:
				format_strings=','.join(['%s'] * len(record_list)) #will convert to val like %s,%s,%s,%s ..
				sql_query="select * from  IPexploits  where (service_type='unknown' or service_type ='echo' or service_type='new') and id in (%s) and Pid = %%s" % format_strings 
				print "SQL QUERY IS :" +str(sql_query)
				args=record_list +[int(project_id)]
				self.cursor.execute(sql_query,args)
				rows=self.cursor.fetchall()

			self.close_connection()
			return rows
		except Exception ,ee:
			print str(ee)
			self.print_Error("Exception in GetUnknown Services"+str(ee))
			self.close_connection()

	def removeIPexploit(self,id_,all_= False,project_id=None):# print logs only when all=false ,as all=true is b4 setting the logger and woulddeadlock code
		"""
		Objective :
		The purpose of this method is to remove a record from IPexploits table.If we are rescanning
		with flag as delete old records then it shall delete all records of current project id
 		"""

		try:
			self.init_connection()
			self.method_id="RemoveIPExploit()"
			#self.print_Log("Starting method --> "+self.method_id)
			if (all_==False):
				self.print_Log("Starting method --> "+self.method_id)
				if project_id==None:
					self.cursor.execute("delete from IPexploits where id = %s",(int(id_),))
				else:
					self.cursor.execute("delete from IPexploits where id = %s and Pid=%s",(int(id_),int(project_id)))
				self.print_Log("Exiting method -->"+self.method_id)
			elif(all_==True):
				self.cursor.execute("delete from IPexploits where Pid= %s",(int(id_),))
			self.con.commit();
			self.close_connection()
			#self.print_Log("Exiting method -->"+self.method_id)
		except Exception ,ee:
			if (all_==False):
				self.print_Error("Exception RemoveIPexploit -->"+str(ee))
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()

	
	def Exists(self,project_id):
		"""
		Objective :
		The purpose of this method is to check weather a given record /Project id exists in the database 
		table ipexploits or not
 		"""
		try:
			print "IN exists with Pid" +str(project_id)
			self.init_connection()
			print "Connection init done()"
			self.method_id="Exists()"
			#self.print_Log("Starting method --> "+self.method_id)
			print "Logg printed"
			self.cursor.execute("select count(Pid) from IPexploits where Pid = %s",(int(project_id),))
			data=self.cursor.fetchone()
			return_val=0
			if (data):
				if (int(data[0]) >0):
					return_val=1
				else:
					return_val=0
			else:
				return_val=0
			#self.con.commit();
			self.close_connection()
			#self.print_Log("Exiting method -->"+self.method_id)
			return return_val
		except Exception ,ee:
			#self.print_Error("EXception -->"+str(ee))
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()
			return return_val
		
	def insertIPexploits(self,IPexploits,single=False):
		"""
		Objective :
		The purpose of this method is to insert the default template and other details in the ipexploits
 		table when the details are parsed from the IPtable_history ,then they are organised as a list of
 		rows and all rows are inserted in this table
 		"""
		try:
			print "\n\n Inside insert IPexploits --"
			self.init_connection()
			self.method_id="InsertIPExploits()"
			record_id=0
			self.print_Log("{*}-Starting method --> "+self.method_id)
			if single==False :
				self.print_Log("Inserting many records")
				self.cursor.executemany("insert into IPexploits (Pid,Host,Port,Service,Project_status,Exploits,service_type,State,Version) values (%s,%s,%s,%s,%s,%s,%s,%s,%s)",IPexploits)
			elif single==True:
				self.print_Log("Inserting single record")
				self.cursor.execute("insert into IPexploits (Pid,Host,Port,Service,Project_status,Exploits,service_type) values (%s,%s,%s,%s,%s,%s,%s)",IPexploits)
				record_id=self.cursor.lastrowid
			#cursor.executemany("insert into test (f1,f2,f3,f4) values (%s,%s,%s,%s)",BulkList)
			self.con.commit();
			self.close_connection()
			return record_id

		except Exception ,ee:
			self.print_Error("EXception -->"+str(ee))
			print ('exception '+str(ee))
			self.con.rollback();
			self.close_connection()


	
	def get_processId(self,project_id,concurrent=False):
		"""
		Objective :
		The purpose of this method is to obtain the exploit process id of the process that maps with the
 		project_id
 		"""
		try:
			print "Project id is :" +str(project_id)
			self.init_connection()	
			if concurrent==False:
				self.cursor.execute("SELECT exploits_process_id from project where id=%s",(int(project_id),))
			else:
				self.cursor.execute("SELECT exploit_process_id_list from project where id=%s",(int(project_id),))
			cursor_=self.cursor.fetchone()
			self.close_connection()
			print str(cursor_[0])
			if cursor_ :
				return str(cursor_[0])
			else:
				return 0

		except Exception ,ee:
			self.print_Log("Exception in getprocess_id "+str(ee))
			self.close_connection()

	def UpdatePid(self,project_id,process_id,concurrent=False):
		"""
		Objective :
		The purpose of this method is to update  the process id of the exploit process that maps with the
 		project_id
 		"""
		
		try:
			print "Project id is :" +str(project_id)
			self.init_connection()	
			if concurrent==False:
				self.cursor.execute("update project set exploits_process_id=%s where id=%s",(process_id,int(project_id)))
			else:
				self.cursor.execute("update project set exploit_process_id_list=%s where id=%s",(process_id,int(project_id)))
			self.con.commit()	
			self.close_connection()
			return 1
			
		except Exception ,ee:
			self.print_Log("Exception in Updategetprocess_id "+str(ee))
			self.con.rollback()
			self.close_connection()
			return 0


	def print_Log(self,message):
		"""
		Objective :
		The purpose of this method is to print the messages to the log file
 		"""
		
		#self.Log_file=str(self.project_id) +str("_Log_file_info")
		#self.logger=self.Auto_logger.configureLoggerInfo(self.method_id,self.Log_file)
		if self.logger is not None:
			try:
				self.lock.acquire()
				self.logger.debug(message)
				self.lock.release()	
			except Exception ,ee:
				self.lock.acquire()
				self.logger.critical(message +"--Exception :  --"+str(ee))
				self.lock.release()
			print "Message is : " +message+"\n"

	
		
	def print_Error(self,message):
		"""
		Objective :
		The purpose of this method is to print errors to the log file
 		"""
		
		#self.Log_file=str(self.project_id) +str("_Log_file_info")
		#self.logger=self.Auto_logger.configureLoggerInfo(self.method_id,self.Log_file)
		#message="Command id --> "+str(self.command_id) +"  Message --> :" +str(message)
		if self.logger is not None:
			try:
				self.lock.acquire()
				self.logger.error(message)
				self.lock.release()
			except Exception ,ee:
				self.lock.acquire()
				self.logger.error(message +"--Exception :  --"+str(ee))
				self.lock.release()
		print message+"\n"



"""obj=IPexploits()
#print "started"
resp=obj.generate_report_GUI(246)
print str(resp)"""
		
